/*
 * Copyright (C) 1999, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011,
 * 2012, 2013 Free Software Foundation, Inc.
 * Copyright (C) 2022 Astie Teddy and pBat developers.
 *
 * This file is part of pBat libfasteval based on libmatheval
 *
 * pBat libfasteval is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * pBat libfasteval is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with pBat libfasteval.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

%{
/*
 * Copyright (C) 1999, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011,
 * Copyright (C) 2022 Astie Teddy and pBat developers.
 * 
 * pBat libfasteval is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * pBat libfasteval is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with pBat libfasteval.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <math.h>

/* Variables used to communicate with code using parser.  */
extern _Thread_local double result;
extern _Thread_local _Bool ok;

extern double (*get_var)(const char *);
extern double (*set_var)(char *, double);

double evaluate_function(const char *name, double arg);

/* Report parsing error.  */
int yyerror (char *s);

/* Function used to tokenize string representing function (this function
 * is generated by scanner generator).  */
extern int yylex (void);

/* Function used to reset string representing function (this function is
 * generated by scanner generator).  */
extern void input_reset (void);

/* Consider x as a double */
#define AS_DOUBLE(x) ((x).is_double ? (x).value.d : (double)(x).value.i)

/* Consider x as an integer */
#define AS_INTEGER(x) ((x).is_double ? (long long)(x).value.d : (x).value.i)

/* Define a binary operation where :
  - if a and b are integer : result = a 'op' b as integer
  - otherwise : result = a 'op' b as double
 */
#define INT_FLOAT_OP(op, result, a, b) \
  if ((a).is_double == 0 && (b).is_double == 0) { \
    /* Both are integer */ \
    (result).is_double = 0; \
    (result).value.i = (a).value.i op (b).value.i; \
  } else { \
    /* One of both is a double */ \
    (result).is_double = 1; \
    (result).value.d = AS_DOUBLE(a) op AS_DOUBLE(b); \
  }
%}

/* Parser semantic values type.  */
%union {
  struct {
    /* Whether the number is a double or an integer. */
    _Bool is_double;
    union {
      long long i;
      double d;
    } value;
  } number;
  char *name;
}

/* Grammar terminal symbols.  */
%token <number> NUMBER CONSTANT
%token <name> FUNCTION VARIABLE
%left '|' 'o' '^'
%left '&' 'a'
%left '>' '<' 
%left '-' '+'
%left '*' '/' '%'
%left '='
%left NEG '!' '~'

/* Grammar non-terminal symbols.  */
%type <number> expression

/* Grammar start non-terminal.  */
%start input

%%

input
: expression '\n' {
  result = AS_DOUBLE($1);
}
;

expression
: NUMBER
| CONSTANT
| expression '+' expression {
  INT_FLOAT_OP(+, $$, $1, $3);
}
| expression '-' expression {
  INT_FLOAT_OP(-, $$, $1, $3);
}
| expression '*' expression {
  INT_FLOAT_OP(*, $$, $1, $3);
}
| expression '/' expression {
  INT_FLOAT_OP(/, $$, $1, $3);
}
| expression '%' expression {
  /* modulo may use integer operator % or fmod function */
  if ($1.is_double == $3.is_double == 0) {
    $$.is_double = 0;
    $$.value.i = $1.value.i % $3.value.i;
  } else {
    $$.is_double = 1;
    $$.value.d = fmod(AS_DOUBLE($1), AS_DOUBLE($3));
  }
}
/* As there is no reason to store the result of a bitwise operator as double,
 * bitwise operators will return an integer value regardless of the type of its
 * operands.
 */
| expression '&' expression {
  $$.is_double = 0;
  $$.value.i = AS_INTEGER($1) & AS_INTEGER($3);
}
| expression 'a' expression {
  $$.is_double = 0;
  $$.value.i = AS_INTEGER($1) && AS_INTEGER($3);
}
| expression '|' expression {
  $$.is_double = 0;
  $$.value.i = AS_INTEGER($1) | AS_INTEGER($3);
}
| expression 'o' expression {
  $$.is_double = 0;
  $$.value.i = AS_INTEGER($1) || AS_INTEGER($3);
}
| expression '^' expression {
  $$.is_double = 0;
  $$.value.i = AS_INTEGER($1) ^ AS_INTEGER($3);
}
| expression '>' expression {
  $$.is_double = 0;
  $$.value.i = AS_INTEGER($1) >> AS_INTEGER($3);
}
|  expression '<' expression {
  $$.is_double = 0;
  $$.value.i = AS_INTEGER($1) << AS_INTEGER($3);
}
| '-' expression %prec NEG {
  $$.is_double = $2.is_double;

  if ($2.is_double)
    $$.value.d = -($2.value.d);
  else
    $$.value.i = -($2.value.i);
}
| '!' expression %prec NEG {
  $$.is_double = 0; /* binary value */

  if ($2.is_double)
    $$.value.i = $2.value.d == 0.0;
  else
    $$.value.i = !($2.value.i);
}
| '~' expression %prec NEG {
  $$.is_double = 0;

  $$.value.i = ~AS_INTEGER($2);
}
| FUNCTION '(' expression ')' {
  $$.is_double = 1;
  $$.value.d = evaluate_function($1, AS_DOUBLE($3));
  free($1);
}
| '(' expression ')' {
  $$ = $2;
}
| VARIABLE '=' expression {
  set_var($1, AS_DOUBLE($3));
  $$ = $3;
}
| VARIABLE {
  /* TODO: Improve this */
  $$.is_double = 1;
  $$.value.d = get_var($1);
}
;

%%

int yyerror(char* s)
{
  /* Indicate parsing error through appropriate flag, reset input
    * string and stop parsing.  */
  ok = 0;
  input_reset();
  return 0;
}
