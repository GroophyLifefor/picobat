/*
 * Copyright (C) 1999, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011,
 * 2012, 2013 Free Software Foundation, Inc.
 * Copyright (C) 2022 Astie Teddy and pBat developers.
 *
 * This file is part of pBat libfasteval based on libmatheval
 *
 * pBat libfasteval is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * pBat libfasteval is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with pBat libfasteval.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

%{
/*
 * Copyright (C) 1999, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011,
 * Copyright (C) 2022 Astie Teddy and pBat developers.
 *
 * pBat libfasteval is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * pBat libfasteval is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with pBat libfasteval.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <math.h>

/* Variables used to communicate with code using parser.  */
extern _Thread_local double result;
extern _Thread_local _Bool ok;

extern double (*get_var)(const char *);
extern double (*set_var)(char *, double);

double evaluate_function(const char *name, double arg);

/* Report parsing error.  */
int yyerror (char *s);

/* Function used to tokenize string representing function (this function
 * is generated by scanner generator).  */
extern int yylex (void);

/* Function used to reset string representing function (this function is
 * generated by scanner generator).  */
extern void input_reset (void);

/* Consider x as a double */
#define AS_DOUBLE(x) ((x).is_double ? (x).d : (double)(x).i)

/* Consider x as an integer */
#define AS_INTEGER(x) ((x).is_double ? (long long)(x).d : (x).i)

/* Define a binary operation where :
  - if a and b are integer : result = a 'op' b as integer
  - otherwise : result = a 'op' b as double
 */
#define INT_FLOAT_OP(op, result, a, b) \
    (result).is_double = (a).is_double || (b).is_double; \
    if (!(result).is_double) \
        (result).i = (a).i op (b).i; \
    (result).d = (a).d op (b).d;


#define INT_OP(op, result, a, b) \
    (result).is_double = (a).is_double || (b).is_double; \
    if (!(result).is_double) \
        (result).i = (a).i op (b).i; \
    (result).d = (double)((int)(a).d op  (int)(b).d);
%}

/* Parser semantic values type.  */
%union {
  struct {
    /* Whether the number is a double or an integer. */
    _Bool is_double;
    long long i;
    double d;
  } number;
  char *name;
}

/* Grammar terminal symbols.  */
%token <number> NUMBER CONSTANT
%token <name> FUNCTION VARIABLE
%left '|' 'o' '^'
%left '&' 'a'
%left '>' '<'
%left '-' '+'
%left '*' '/' '%'
%left '='
%left NEG '!' '~'

/* Grammar non-terminal symbols.  */
%type <number> expression

/* Grammar start non-terminal.  */
%start input

%%

input
: expression '\n' {
  result = AS_DOUBLE($1);
}
;

expression
: NUMBER
| CONSTANT
| expression '+' expression {
  INT_FLOAT_OP(+, $$, $1, $3);
}
| expression '-' expression {
  INT_FLOAT_OP(-, $$, $1, $3);
}
| expression '*' expression {
  INT_FLOAT_OP(*, $$, $1, $3);
}
| expression '/' expression {
  INT_FLOAT_OP(/, $$, $1, $3);
}
| expression '%' expression {

  /* modulo may use integer operator % or fmod function */
  $$.is_double  = $1.is_double || $3.is_double;
  if (!($$.is_double))
    $$.i = $1.i % $3.i;
  $$.d = fmod($1.d, $3.d);

}
/* As there is no reason to store the result of a bitwise operator as double,
 * bitwise operators will return an integer value regardless of the type of its
 * operands.
 */
| expression '&' expression {
  INT_OP(&, $$, $1, $3)
}
| expression '|' expression {
  INT_OP(|, $$, $1, $3)
}
| expression 'o' expression {
  INT_OP(||, $$, $1, $3)
}
| expression 'a' expression {
  INT_OP(&&, $$, $1, $3)
}
| expression '^' expression {
  INT_OP(^, $$, $1, $3)
}
| expression '>' expression {
  INT_OP(>>, $$, $1, $3)
}
|  expression '<' expression {
  INT_OP(<<, $$, $1, $3)
}
| '-' expression %prec NEG {
  $$.is_double = $2.is_double;

  if (!$2.is_double)
    $$.i = -($2.i);
  $$.d = - $2.d;

}
| '!' expression %prec NEG {
  $$.is_double = $2.is_double;

  if (!$2.is_double)
    $$.i = !($2.i);
  $$.d = (double)(! (int)$2.d);
}
| '~' expression %prec NEG {
  $$.is_double = $2.is_double;

  if (!$2.is_double)
    $$.i = ~($2.i);
  $$.d = (double)(~ (int)$2.d);
}
| FUNCTION '(' expression ')' {
  $$.is_double = 1;
  $$.d = evaluate_function($1, AS_DOUBLE($3));
  free($1);
}
| '(' expression ')' {
  $$ = $2;
}
| VARIABLE '=' expression {
  set_var($1, AS_DOUBLE($3));
  $$ = $3;
}
| VARIABLE {
  /* TODO: Improve this */
  $$.is_double = 0;
  $$.d = get_var($1);
  $$.i = (int)$$.d;
}
;

%%

int yyerror(char* s)
{
  /* Indicate parsing error through appropriate flag, reset input
    * string and stop parsing.  */
  ok = 0;
  input_reset();
  return 0;
}
